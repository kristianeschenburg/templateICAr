library(roxygen2)
library(roxygen2md)
usethis::use_roxygen_md()
roxygenize()
roxygenize()
roxygenize()
roxygenize()
roxygenize()
roxygenize()
roxygenize()
roxygenize()
roxygenize()
roxygenize()
TRUE==1
# Check only 0s and 1s
values <- sort(unique(mask))
roxygenize()
roxygenize()
roxygenize()
library(R.matlab) #readMat
library(matrixStats) #colVars
library(INLA)
inla.setOption(pardiso.license = '~/pardiso.lic')
setwd('~/Dropbox/RESEARCH/SpatialTemplateICA/simulation')
Nx <- 46
Ny <- 55
N <- Nx*Ny #number of voxels
groupICs <- readMat('groupICs.mat')
GICA <- groupICs$tempICmean.s
template_mean <- groupICs$tempICmean.p #Nx3
template_var <- groupICs$tempICvar.p #Nx3
subjICs <- readMat('subjICs.mat')
subjICs <- subjICs$subjICs.p #based on perturbing group settings (results in smooth deviations)
n <- dim(subjICs)[1] #number of subjects
n <- 2 #start with just a few subjects
ts1 <- scale(read.csv('ts1_645450.csv', header=FALSE))
ts2 <- scale(read.csv('ts2_645450.csv', header=FALSE))
ts <- rbind(ts1,ts2)
rm(ts1, ts2)
#determine signal variance for SNR to fix error variance
tvar <- matrix(0,3,16)
#identify peak voxels for each IC (top 1% of each IC)
quantile99 <- apply(template_mean, 2, quantile, probs=0.99, na.rm=TRUE)
peaks <- (template_mean > matrix(quantile99, ncol=3, nrow=N, byrow=TRUE))
for(q in 1:3){
for(l in 1:16){ #loop through all 16 candidate timecourses
tc_lq <- ts[,l] %*% t(template_mean[peaks[,q],q]); #temporal signal l for IC q at each peak voxel
tvar[q,l] <- mean(colVars(tc_lq)); #average temporal variance of those time courses over peak voxels
}
}
sd_sig <- sqrt(mean(tvar))
sd_err <- 2*sd_sig #for SNR=sd_sig/sd_err=0.5
#generate fMRI data
Dat <- array(0, dim=c(n,2400,N))
for(ii in 1:n){
print(ii)
inds <- sample(16,3); #select 3 of the 16 real timecourses to use
ts_ii <- ts[,inds]
#Generate residuals
E_ii <- matrix(rnorm(2400*N,mean=0,sd=sd_err),nrow=2400,ncol=N)
#Generate fMRI data
Dat[ii,,] <- ts_ii %*% subjICs[ii,,] + E_ii
}
source('~/Box/SOFTWARE/templateICAr/R/make_mesh.R')
source('~/Box/SOFTWARE/templateICAr/R/dim_reduce.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/make_mesh.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/dim_reduce.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/dual_reg.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/scale_BOLD.R')
#make mesh for spatial template ICA
mask <- matrix(1,Nx,Ny)
mymesh <- make_mesh(mask)
S_DR <- array(NA, dim=c(n,3,N)) #save IC estimates
C_DR <- array(NA, dim=c(n,3,3)) #save FC matrices
ii=1
dat_ii <- Dat[ii,,] #TxV
subjIC_DR_ii <- dual_reg(dat_ii, t(template_mean))
S_DR[ii,,] <- subjIC_DR_ii$S
C_DR[ii,,] <- cor(subjIC_DR_ii$A)
dat_ctr <- subjIC_DR_ii$dat_ctr
template_mean = t(template_mean)
template_var = t(template_var)
BOLD = dat_ctr
mesh=mymesh
ntime <- nrow(BOLD) #length of timeseries
nvox <- ncol(BOLD) #number of data locations
L <- nrow(template_mean) #number of ICs
ntime
nvox
L
#check that the number of data locations (nvox), time points (ntime) and ICs (L) makes sense
if(ntime > nvox) warning('More time points than voxels. Are you sure?')
if(L > nvox) stop('The arguments you supplied suggest that you want to estimate more ICs than you have data locations.  Please check the orientation and size of template_mean, template_var and BOLD.')
if(L > ntime) stop('The arguments you supplied suggest that you want to estimate more ICs than you have time points.  Please check the orientation and size of template_mean, template_var and BOLD.')
#check that all arguments have consistent number of data locations (nvox) and ICs (L)
if(ncol(template_mean) != nvox | ncol(template_var) != nvox) stop('template_mean, template_var and BOLD must have same number of data locations (columns), but they do not.')
if(nrow(template_var) != L) stop('template_mean and template_var must have the same number of ICs (rows), but they do not.')
class(mesh)
maxQ <- ntime
maxQ
L
# USE ORIGINAL DATA, SINCE WE ARE ASSUMING NO NUISANCE COMPONENTS
BOLD3 <- BOLD
BOLD3 <- scale_BOLD(BOLD3)
all.equal(BOLD3, BOLD)
dim(BOLD)
dim(BOLD3)
head(BOLD[,1:5])
head(BOLD3[,1:5])
summary(rowMeans(BOLD))
summary(colMeans(BOLD))
summary(colMeans(BOLD3))
summary(rowMeans(BOLD3))
sum((BOLD-BOLD3)^2)
mean(abs(BOLD-BOLD3))
all.equal(BOLD3, BOLD, check.attributes=FALSE)
dat <- dim_reduce(BOLD3, L)
dim(dat)
dim(dat$data_reduced)
#residual variance
sigma_sq = mean(D2)
#prewhitening matrix
H = diag(1/sqrt(D1 - sigma_sq)) %*% t(U)
dim(BOLD3)
dim(ts)
dim(dat_ii)
dat_ii <- Dat[ii,1:ntime,] #TxV
dim(dat_ii)
ntime <- 200
dat_ii <- Dat[ii,1:ntime,] #TxV
dim(dat_ii)
subjIC_DR_ii <- dual_reg(dat_ii, t(template_mean))
S_DR[ii,,] <- subjIC_DR_ii$S
template_mean <- t(template_mean)
template_var <- t(template_var)
dat_ii <- Dat[ii,1:ntime,] #TxV
subjIC_DR_ii <- dual_reg(dat_ii, template_mean)
template_mean <- t(template_mean)
template_var <- t(template_var)
subjIC_DR_ii <- dual_reg(dat_ii, template_mean)
S_DR[ii,,] <- subjIC_DR_ii$S
C_DR[ii,,] <- cor(subjIC_DR_ii$A)
dat_ctr <- subjIC_DR_ii$dat_ctr
BOLD = dat_ctr
ntime <- nrow(BOLD) #length of timeseries
nvox <- ncol(BOLD) #number of data locations
L <- nrow(template_mean) #number of ICs
ntime
nvox
L
if(ntime > nvox) warning('More time points than voxels. Are you sure?')
if(L > nvox) stop('The arguments you supplied suggest that you want to estimate more ICs than you have data locations.  Please check the orientation and size of template_mean, template_var and BOLD.')
if(L > ntime) stop('The arguments you supplied suggest that you want to estimate more ICs than you have time points.  Please check the orientation and size of template_mean, template_var and BOLD.')
#check that all arguments have consistent number of data locations (nvox) and ICs (L)
if(ncol(template_mean) != nvox | ncol(template_var) != nvox) stop('template_mean, template_var and BOLD must have same number of data locations (columns), but they do not.')
if(nrow(template_var) != L) stop('template_mean and template_var must have the same number of ICs (rows), but they do not.')
#check that the supplied mesh object is of type templateICA_mesh
if(is.null(mesh)){
message('No mesh supplied: Using standard template ICA model, which assumes spatial independence. If this is not what you want, stop and supply a valid mesh. See help(make_mesh).')
} else if(class(mesh) != 'templateICA_mesh'){
stop('mesh argument should be of class templateICA_mesh. See help(make_mesh).')
}
maxQ=3
if(is.null(maxQ)) maxQ <- ntime
if(maxQ < L){
warning('maxQ must be at least L.  Setting maxQ=L.')
maxQ <- L
}
if(maxQ > ntime){
warning('maxQ must be no more than T.  Setting maxQ = T.')
maxQ <- ntime
}
maxQ
if(maxQ > L){
#i. PERFORM DUAL REGRESSION TO GET INITIAL ESTIMATE OF TEMPLATE ICS
#ii. SUBTRACT THOSE ESTIMATES FROM THE ORIGINAL DATA --> BOLD2
#iii. ESTIMATE THE NUMBER OF REMAINING ICS USING THE MINKA METHOD (TO DO)
#iv. ESTIMATE THE NUISANCE ICS USING GIFT/INFOMAX (TO DO)
#v. SUBTRACT THOSE ESTIMATES FROM THE ORIGINAL DATA --> BOLD3
} else {
# USE ORIGINAL DATA, SINCE WE ARE ASSUMING NO NUISANCE COMPONENTS
BOLD3 <- BOLD
}
BOLD3 <- scale_BOLD(BOLD3)
dat <- dim_reduce(BOLD3, L)
source('~/Box Sync/SOFTWARE/templateICAr/R/make_mesh.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/dim_reduce.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/dual_reg.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/scale_BOLD.R')
dat <- dim_reduce(BOLD3, L)
dim(dat$data_reduced)
dim(BOLD3)
BOLD4 <- dat$data_reduced
H <- dat$H
Hinv <- dat$Hinv
C_diag <- dat$C_diag
#initialize mixing matrix (use dual regression-based estimate for starting value)
dat_DR <- dual_reg(BOLD3, template_mean)
#dat_DR$A <- scale(dat_DR$A) #would this have the same effect as the code below?
HA <- H %*% dat_DR$A #apply dimension reduction
HA <- orthonorm(HA)  #orthogonalize
source('~/Box Sync/SOFTWARE/templateICAr/R/EM_algorithm.R')
HA <- orthonorm(HA)  #orthogonalize
sd_A <- sqrt(colVars(Hinv %*% HA)) #get scale of A (after reverse-prewhitening)
dim(Hinv)
dim(H)
Hinv <- dat_list$H_inv
dat_list <- dat
rm(dat)
Hinv <- dat_list$H_inv
sd_A <- sqrt(colVars(Hinv %*% HA)) #get scale of A (after reverse-prewhitening)
HA <- HA %*% diag(1/sd_A) #standardize scale of A
theta0 <- list(A = HA)
HA
n <- 1 #start with one subject
Dat <- array(0, dim=c(n,2400,N))
for(ii in 1:n){
print(ii)
inds <- sample(16,3); #select 3 of the 16 real timecourses to use
ts_ii <- ts[,inds]
#Generate residuals
E_ii <- matrix(rnorm(2400*N,mean=0,sd=sd_err),nrow=2400,ncol=N)
#Generate fMRI data
Dat[ii,,] <- ts_ii %*% subjICs[ii,,] + E_ii
}
ntime <- 200
dim(ts_ii)
cor(ts_ii)
cor(ts_ii[1:200,])
C_true[ii,,] <- cor(ts_ii)
C_true <- array(NA, dim=c(n,3,3)) #save FC matrices
C_true[ii,,] <- cor(ts_ii)
C_true
C_true[1,,]
dim(dat_DR)
names(dat_DR)
dim(dat_DR$A)
cor(dat_DR$A)
dat_ii <- Dat[ii,1:ntime,] #TxV
subjIC_DR_ii <- dual_reg(dat_ii, template_mean)
S_DR[ii,,] <- subjIC_DR_ii$S
C_DR[ii,,] <- cor(subjIC_DR_ii$A)
dat_ctr <- subjIC_DR_ii$dat_ctr
cor(dat_DR$A)
cor(subjIC_DR_ii$A)
C_DR[ii,,]
BOLD = dat_ctr
ntime <- nrow(BOLD) #length of timeseries
nvox <- ncol(BOLD) #number of data locations
L <- nrow(template_mean) #number of ICs
#check that the number of data locations (nvox), time points (ntime) and ICs (L) makes sense
if(ntime > nvox) warning('More time points than voxels. Are you sure?')
if(L > nvox) stop('The arguments you supplied suggest that you want to estimate more ICs than you have data locations.  Please check the orientation and size of template_mean, template_var and BOLD.')
if(L > ntime) stop('The arguments you supplied suggest that you want to estimate more ICs than you have time points.  Please check the orientation and size of template_mean, template_var and BOLD.')
#check that all arguments have consistent number of data locations (nvox) and ICs (L)
if(ncol(template_mean) != nvox | ncol(template_var) != nvox) stop('template_mean, template_var and BOLD must have same number of data locations (columns), but they do not.')
if(nrow(template_var) != L) stop('template_mean and template_var must have the same number of ICs (rows), but they do not.')
#check that the supplied mesh object is of type templateICA_mesh
if(is.null(mesh)){
message('No mesh supplied: Using standard template ICA model, which assumes spatial independence. If this is not what you want, stop and supply a valid mesh. See help(make_mesh).')
} else if(class(mesh) != 'templateICA_mesh'){
stop('mesh argument should be of class templateICA_mesh. See help(make_mesh).')
}
#check that maxQ makes sense
if(is.null(maxQ)) maxQ <- ntime
if(maxQ < L){
warning('maxQ must be at least L.  Setting maxQ=L.')
maxQ <- L
}
if(maxQ > ntime){
warning('maxQ must be no more than T.  Setting maxQ = T.')
maxQ <- ntime
}
# USE ORIGINAL DATA, SINCE WE ARE ASSUMING NO NUISANCE COMPONENTS
BOLD3 <- BOLD
BOLD3 <- scale_BOLD(BOLD3)
dat_list <- dim_reduce(BOLD3, L)
BOLD4 <- dat_list$data_reduced
H <- dat_list$H
Hinv <- dat_list$H_inv
C_diag <- dat_list$C_diag
#initialize mixing matrix (use dual regression-based estimate for starting value)
dat_DR <- dual_reg(BOLD3, template_mean)
cor(dat_DR$A)
#dat_DR$A <- scale(dat_DR$A) #would this have the same effect as the code below?
HA <- H %*% dat_DR$A #apply dimension reduction
dim(HA)
cor(HA)
HA <- orthonorm(HA)  #orthogonalize
sd_A <- sqrt(colVars(Hinv %*% HA)) #get scale of A (after reverse-prewhitening)
HA <- HA %*% diag(1/sd_A) #standardize scale of A
dim(HA)
cor(HA)
theta0 <- list(A = HA)
dat_list$sigma_sq
#initialize residual variance
theta0$nu0_sq = dat_list$sigma_sq
dat_test <- dim_reduce(t(BOLD3), L)
#dat_DR$A <- scale(dat_DR$A) #would this have the same effect as the code below?
HA <- H %*% dat_DR$A #apply dimension reduction
HA <- orthonorm(HA)  #orthogonalize
sd_A <- sqrt(colVars(Hinv %*% HA)) #get scale of A (after reverse-prewhitening)
HA <- HA %*% diag(1/sd_A) #standardize scale of A
theta0 <- list(A = HA)
#initialize residual variance
theta0$nu0_sq = dat_list$sigma_sq #this value is huge.  what if we switch the observations and variables in the dimension reduction step?
#initialize kappa parameters (spatial model only)
if(!is.null(mesh)) theta0$kappa <- rep(1, Q)
if(is.null(mesh)) {
resultEM <- EM_templateICA(tempICmean, tempICvar, BOLD4, theta0, C_diag)
} else {
resultEM <- EM_templateICA(tempICmean, tempICvar, mesh, BOLD4, theta0, C_diag)
#TO DO: revise EM_algorithm function to take mesh (made from make_mesh) instead of spde
#TO DO: make a wrapper EM_templateICA function to call the right algorithm
}
#' @param BOLD (TxV matrix) BOLD fMRI data matrix, where T is the number of volumes (time points) and V is the number of brain locations
#' @param mesh Object of type \code{templateICA_mesh} created by \code{make_mesh()} (in which case spatial priors are assumed on each independent component) or NULL (in which case spatial independence is assumed.)
#' @param maxQ Maximum number of ICs (template+nuisance) to identify (L <= maxQ <= T)
#' @param maxiter Maximum number of EM iterations
#' @param epsilon Smallest proportion change between iterations (e.g. .01 or 1%)
#'
#' @return A list containing the estimated independent components S (a LxV matrix), their mixing matrix A (a TxL matrix), and the number of nuisance ICs estimated (Q_nuis)
#' @export
#'
#' @examples
templateICA <- function(template_mean, template_var, BOLD, mesh=NULL, maxQ=NULL, maxiter=100, epsilon=0.01){
ntime <- nrow(BOLD) #length of timeseries
nvox <- ncol(BOLD) #number of data locations
L <- nrow(template_mean) #number of ICs
#check that the number of data locations (nvox), time points (ntime) and ICs (L) makes sense
if(ntime > nvox) warning('More time points than voxels. Are you sure?')
if(L > nvox) stop('The arguments you supplied suggest that you want to estimate more ICs than you have data locations.  Please check the orientation and size of template_mean, template_var and BOLD.')
if(L > ntime) stop('The arguments you supplied suggest that you want to estimate more ICs than you have time points.  Please check the orientation and size of template_mean, template_var and BOLD.')
#check that all arguments have consistent number of data locations (nvox) and ICs (L)
if(ncol(template_mean) != nvox | ncol(template_var) != nvox) stop('template_mean, template_var and BOLD must have same number of data locations (columns), but they do not.')
if(nrow(template_var) != L) stop('template_mean and template_var must have the same number of ICs (rows), but they do not.')
#check that the supplied mesh object is of type templateICA_mesh
if(is.null(mesh)){
message('No mesh supplied: Using standard template ICA model, which assumes spatial independence. If this is not what you want, stop and supply a valid mesh. See help(make_mesh).')
} else if(class(mesh) != 'templateICA_mesh'){
stop('mesh argument should be of class templateICA_mesh. See help(make_mesh).')
}
#check that maxQ makes sense
if(is.null(maxQ)) maxQ <- ntime
if(maxQ < L){
warning('maxQ must be at least L.  Setting maxQ=L.')
maxQ <- L
}
if(maxQ > ntime){
warning('maxQ must be no more than T.  Setting maxQ = T.')
maxQ <- ntime
}
### 1. ESTIMATE AND DEAL WITH NUISANCE ICS (unless maxQ = L)
if(maxQ > L){
#i. PERFORM DUAL REGRESSION TO GET INITIAL ESTIMATE OF TEMPLATE ICS
#ii. SUBTRACT THOSE ESTIMATES FROM THE ORIGINAL DATA --> BOLD2
#iii. ESTIMATE THE NUMBER OF REMAINING ICS USING THE MINKA METHOD (TO DO)
#iv. ESTIMATE THE NUISANCE ICS USING GIFT/INFOMAX (TO DO)
#v. SUBTRACT THOSE ESTIMATES FROM THE ORIGINAL DATA --> BOLD3
} else {
# USE ORIGINAL DATA, SINCE WE ARE ASSUMING NO NUISANCE COMPONENTS
BOLD3 <- BOLD
}
### 2. PERFORM DIMENSION REDUCTION --> BOLD4
BOLD3 <- scale_BOLD(BOLD3)
dat_list <- dim_reduce(BOLD3, L)
BOLD4 <- dat_list$data_reduced
H <- dat_list$H
Hinv <- dat_list$H_inv
C_diag <- dat_list$C_diag
### 3. SET INITIAL VALUES FOR PARAMETERS
#initialize mixing matrix (use dual regression-based estimate for starting value)
dat_DR <- dual_reg(BOLD3, template_mean)
#dat_DR$A <- scale(dat_DR$A) #would this have the same effect as the code below?
HA <- H %*% dat_DR$A #apply dimension reduction
HA <- orthonorm(HA)  #orthogonalize
sd_A <- sqrt(colVars(Hinv %*% HA)) #get scale of A (after reverse-prewhitening)
HA <- HA %*% diag(1/sd_A) #standardize scale of A
theta0 <- list(A = HA)
#initialize residual variance
theta0$nu0_sq = dat_list$sigma_sq #this value is huge.  what if we switch the observations and variables in the dimension reduction step?
#initialize kappa parameters (spatial model only)
if(!is.null(mesh)) theta0$kappa <- rep(1, Q)
### 4. RUN EM ALGORITHM!
if(is.null(mesh)) {
resultEM <- EM_templateICA(tempICmean, tempICvar, BOLD4, theta0, C_diag)
} else {
resultEM <- EM_templateICA(tempICmean, tempICvar, mesh, BOLD4, theta0, C_diag)
#TO DO: revise EM_algorithm function to take mesh (made from make_mesh) instead of spde
#TO DO: make a wrapper EM_templateICA function to call the right algorithm
}
}
