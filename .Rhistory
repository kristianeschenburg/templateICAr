print(paste0('Using ', length(inds),' truly non-zero voxels in calculation'))
truth2 <- truth[inds]
estimate2 <- estimate[inds]
beta <- as.vector(solve(t(truth2) %*% truth2) %*% t(truth2) %*% estimate2)
beta
visualize_vec2img(
values = t(est2),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(0, 5)
)
visualize_vec2img(
values = t(est2),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(0, 1)
)
visualize_vec2img(
values = t(est2),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(0, 0.5)
)
summary(est2[1,])
visualize_vec2img(
values = t(est2),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(-0.3, 0.3)
)
summary(lm(estimate2 ~ truth2))
summary(lm(estimate ~ truth))
for(ii in 1:n){
print(paste0('~~~~~~~~~~~ SUBJECT ',ii,' ~~~~~~~~~~~~~~'))
### PERFORM DUAL REGRESSION
dat_ii <- Dat[ii,1:ntime,] #TxV
subjIC_DR_ii <- dual_reg(dat_ii, template_mean)
S_DR[ii,,] <- subjIC_DR_ii$S
C_DR[ii,,] <- cor(subjIC_DR_ii$A)
dat_ctr <- subjIC_DR_ii$dat_ctr
### PERFORM STANDARD TEMPLATE ICA
### PERFORM SPATIAL TEMPLATE ICA
subjIC_stICA_ii <-
templateICA(template_mean = template_mean,
template_var = template_var,
BOLD = dat_ctr,
mesh=mymesh, #mesh != NULL => use spatial template ICA model
maxQ=3) #no nuisance ICs
success[ii,2] <- subjIC_stICA_ii$success_flag
nu0_sq_hat[ii,2] <- subjIC_stICA_ii$theta_MLE$nu0_sq
kappa_hat[ii,] <- subjIC_stICA_ii$theta_MLE$kappa
S_stICA[ii,,] <- as.matrix(subjIC_stICA_ii$subjICmean)
S_stICA_var[ii,,] <- as.matrix(subjIC_stICA_ii$subjICvar)
C_stICA1[ii,,] <- cor(subjIC_stICA_ii$A)
C_stICA2[ii,,] <- cor(subjIC_stICA_ii$A_reg)
}
source('~/Dropbox/RESEARCH/SpatialTemplateICA/simulation/simulation.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/make_mesh.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/dim_reduce.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/dual_reg.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/scale_BOLD.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/EM_algorithm.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/templateICA.R')
ii=1
dat_ii <- Dat[ii,1:ntime,] #TxV
subjIC_DR_ii <- dual_reg(dat_ii, template_mean)
S_DR[ii,,] <- subjIC_DR_ii$S
C_DR[ii,,] <- cor(subjIC_DR_ii$A)
dat_ctr <- subjIC_DR_ii$dat_ctr
subjIC_stICA_ii <-
templateICA(template_mean = template_mean,
template_var = template_var,
BOLD = dat_ctr,
mesh=mymesh, #mesh != NULL => use spatial template ICA model
maxQ=3) #no nuisance ICs
median(est1[1,])
median(est1[2,])
median(est1[3,])
median(est2[1,])
median(est2[2,])
median(est2[3,])
rescale <- function(estimate, truth){
estimate <- estimate - median(estimate) #make median zero
inds <- which(truth > 0)
print(paste0('Using ', length(inds),' truly non-zero voxels in calculation'))
truth2 <- truth[inds]
estimate2 <- estimate[inds]
beta <- as.vector(solve(t(truth2) %*% truth2) %*% t(truth2) %*% estimate2)
est_rescale <- estimate/beta
return(est_rescale)
}
est1_rescale <- est1*0
est2_rescale <- est2*0
for(k in 1:3){
est1_rescale[k,] <- rescale(est1[k,], troo[k,])
est2_rescale[k,] <- rescale(est2[k,], troo[k,])
}
visualize_vec2img(
values = t(est1_rescale),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(0, 5)
)
visualize_vec2img(
values = t(troo),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(0, 6)
p1 <- visualize_vec2img(
values = t(troo),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(0, 6)
)
visualize_vec2img(
values = t(troo),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(0, 6)
)
visualize_vec2img(
values = t(troo),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(-1, 6)
)
visualize_vec2img(
values = t(troo),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('purple','blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(-1, 6)
)
median(troo[1,])
median(troo[2,])
median(troo[3,])
rescale <- function(estimate, truth){
truth <- truth - median(truth) #make median zero
estimate <- estimate - median(estimate) #make median zero
inds <- which(truth > 0)
print(paste0('Using ', length(inds),' truly non-zero voxels in calculation'))
truth2 <- truth[inds]
estimate2 <- estimate[inds]
beta <- as.vector(solve(t(truth2) %*% truth2) %*% t(truth2) %*% estimate2)
est_rescale <- estimate/beta
return(est_rescale)
}
est1_rescale <- est1*0
est2_rescale <- est2*0
for(k in 1:3){
est1_rescale[k,] <- rescale(est1[k,], troo[k,])
est2_rescale[k,] <- rescale(est2[k,], troo[k,])
}
troo[1,] - troo[1,] - median(troo[1,])
troo[2,] - troo[2,] - median(troo[2,])
troo[3,] - troo[3,] - median(troo[3,])
p1 <- visualize_vec2img(
values = t(troo),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('purple','blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(-1, 6)
)
p1 <- visualize_vec2img(
values = t(troo),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(0, 6)
)
p2 <- visualize_vec2img(
values = t(est1_rescale),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(0, 6)
)
p3 <- visualize_vec2img(
values = t(est2_rescale),
field_names = c('IC1', 'IC2', 'IC3'),
pal = c('blue','turquoise','yellow','orange','red','darkred'),
xy.inds = which(matrix(1, nrow=Nx, ncol=Ny) >= 0, arr.ind=TRUE),
zlim = c(0, 5)
)
grid.arrange(p1, p2, p3, nrow=3)
source('~/Dropbox/RESEARCH/SpatialTemplateICA/simulation/simulation.R')
c
c
c
c
c
library(R.matlab) #readMat
library(matrixStats) #colVars
library(INLA)
inla.setOption(pardiso.license = '~/pardiso.lic')
setwd('~/Dropbox/RESEARCH/SpatialTemplateICA/simulation')
################################
# GENERATE GROUP ICS
################################
### Image settings
Nx <- 46
Ny <- 55
N <- Nx*Ny #number of voxels
groupICs <- readMat('groupICs.mat')
GICA <- groupICs$tempICmean.s
template_mean <- groupICs$tempICmean.p #Nx3
template_var <- groupICs$tempICvar.p #Nx3
subjICs <- readMat('subjICs.mat')
subjICs <- subjICs$subjICs.p #based on perturbing group settings (results in smooth deviations)
n <- dim(subjICs)[1] #number of subjects
n <- 1 #start with one subject
ts1 <- scale(read.csv('ts1_645450.csv', header=FALSE))
ts2 <- scale(read.csv('ts2_645450.csv', header=FALSE))
ts <- rbind(ts1,ts2)
rm(ts1, ts2)
#determine signal variance for SNR to fix error variance
tvar <- matrix(0,3,16)
#identify peak voxels for each IC (top 1% of each IC)
quantile99 <- apply(template_mean, 2, quantile, probs=0.99, na.rm=TRUE)
peaks <- (template_mean > matrix(quantile99, ncol=3, nrow=N, byrow=TRUE))
for(q in 1:3){
for(l in 1:16){ #loop through all 16 candidate timecourses
tc_lq <- ts[,l] %*% t(template_mean[peaks[,q],q]); #temporal signal l for IC q at each peak voxel
tvar[q,l] <- mean(colVars(tc_lq)); #average temporal variance of those time courses over peak voxels
}
}
sd_sig <- sqrt(mean(tvar))
sd_err <- 2*sd_sig #for SNR=sd_sig/sd_err=0.5
#generate fMRI data
Dat <- array(0, dim=c(n,2400,N))
C_true <- array(NA, dim=c(n,3,3)) #save FC matrices
for(ii in 1:n){
print(ii)
inds <- sample(16,3); #select 3 of the 16 real timecourses to use
ts_ii <- ts[,inds]
#Generate residuals
E_ii <- matrix(rnorm(2400*N,mean=0,sd=sd_err),nrow=2400,ncol=N)
#Generate fMRI data
Dat[ii,,] <- ts_ii %*% subjICs[ii,,] + E_ii
C_true[ii,,] <- cor(ts_ii)
}
n <- dim(subjICs)[1] #number of subjects
n
n <- 100
ts1 <- scale(read.csv('ts1_645450.csv', header=FALSE))
ts2 <- scale(read.csv('ts2_645450.csv', header=FALSE))
ts <- rbind(ts1,ts2)
rm(ts1, ts2)
#determine signal variance for SNR to fix error variance
tvar <- matrix(0,3,16)
#identify peak voxels for each IC (top 1% of each IC)
quantile99 <- apply(template_mean, 2, quantile, probs=0.99, na.rm=TRUE)
peaks <- (template_mean > matrix(quantile99, ncol=3, nrow=N, byrow=TRUE))
for(q in 1:3){
for(l in 1:16){ #loop through all 16 candidate timecourses
tc_lq <- ts[,l] %*% t(template_mean[peaks[,q],q]); #temporal signal l for IC q at each peak voxel
tvar[q,l] <- mean(colVars(tc_lq)); #average temporal variance of those time courses over peak voxels
}
}
sd_sig <- sqrt(mean(tvar))
sd_err <- 2*sd_sig #for SNR=sd_sig/sd_err=0.5
#generate fMRI data
Dat <- array(0, dim=c(n,2400,N))
C_true <- array(NA, dim=c(n,3,3)) #save FC matrices
for(ii in 1:n){
print(ii)
inds <- sample(16,3); #select 3 of the 16 real timecourses to use
ts_ii <- ts[,inds]
#Generate residuals
E_ii <- matrix(rnorm(2400*N,mean=0,sd=sd_err),nrow=2400,ncol=N)
#Generate fMRI data
Dat[ii,,] <- ts_ii %*% subjICs[ii,,] + E_ii
C_true[ii,,] <- cor(ts_ii)
}
template_mean <- t(template_mean)
template_var <- t(template_var)
ntime <- 200
source('~/Box Sync/SOFTWARE/templateICAr/R/make_mesh.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/dim_reduce.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/dual_reg.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/scale_BOLD.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/EM_algorithm.R')
source('~/Box Sync/SOFTWARE/templateICAr/R/templateICA.R')
mask <- matrix(1,Nx,Ny)
mymesh <- make_mesh(mask)
S_tICA <- array(NA, dim=c(n,3,N)) #save IC estimates from template ICA
S_tICA_var <- array(NA, dim=c(n,3,N)) #variance of IC estimates from template ICA
C_tICA1 <- array(NA, dim=c(n,3,3)) #save FC matrices from template ICA (using A from EM)
C_tICA2 <- array(NA, dim=c(n,3,3)) #save FC matrices from template ICA (using A from regression of S on dat)
S_stICA <- array(NA, dim=c(n,3,N)) #save IC estimates from spatial template ICA
S_stICA_var <- array(NA, dim=c(n,3,N)) #variance of IC estimates from spatial template ICA
C_stICA1 <- array(NA, dim=c(n,3,3)) #save FC matrices from spatial template ICA (using A from EM)
C_stICA2 <- array(NA, dim=c(n,3,3)) #save FC matrices from spatial template ICA (using A from regression of S on dat)
S_DR <- array(NA, dim=c(n,3,N)) #save IC estimates
C_DR <- array(NA, dim=c(n,3,3)) #save FC matrices
success <- matrix(nrow=n, ncol=2) #tICA, stICA
nu0_sq_hat <- matrix(nrow=n, ncol=2) #tICA, stICA
kappa_hat <- matrix(nrow=n, ncol=3) #stICA only
for(ii in 1:n){
print(paste0('~~~~~~~~~~~ SUBJECT ',ii,' ~~~~~~~~~~~~~~'))
### PERFORM DUAL REGRESSION
dat_ii <- Dat[ii,1:ntime,] #TxV
subjIC_DR_ii <- dual_reg(dat_ii, template_mean)
S_DR[ii,,] <- subjIC_DR_ii$S
C_DR[ii,,] <- cor(subjIC_DR_ii$A)
dat_ctr <- subjIC_DR_ii$dat_ctr
### PERFORM STANDARD TEMPLATE ICA
### PERFORM SPATIAL TEMPLATE ICA
subjIC_stICA_ii <-
templateICA(template_mean = template_mean,
template_var = template_var,
BOLD = dat_ctr,
mesh=mymesh, #mesh != NULL => use spatial template ICA model
maxQ=3) #no nuisance ICs
success[ii,2] <- subjIC_stICA_ii$success_flag
nu0_sq_hat[ii,2] <- subjIC_stICA_ii$theta_MLE$nu0_sq
kappa_hat[ii,] <- subjIC_stICA_ii$theta_MLE$kappa
S_stICA[ii,,] <- as.matrix(subjIC_stICA_ii$subjICmean)
S_stICA_var[ii,,] <- as.matrix(subjIC_stICA_ii$subjICvar)
C_stICA1[ii,,] <- cor(subjIC_stICA_ii$A)
C_stICA2[ii,,] <- cor(subjIC_stICA_ii$A_reg)
}
source('~/Box Sync/SOFTWARE/templateICAr/R/UpdateTheta.R')
for(ii in 1:n){
print(paste0('~~~~~~~~~~~ SUBJECT ',ii,' ~~~~~~~~~~~~~~'))
### PERFORM DUAL REGRESSION
dat_ii <- Dat[ii,1:ntime,] #TxV
subjIC_DR_ii <- dual_reg(dat_ii, template_mean)
S_DR[ii,,] <- subjIC_DR_ii$S
C_DR[ii,,] <- cor(subjIC_DR_ii$A)
dat_ctr <- subjIC_DR_ii$dat_ctr
### PERFORM STANDARD TEMPLATE ICA
### PERFORM SPATIAL TEMPLATE ICA
subjIC_stICA_ii <-
templateICA(template_mean = template_mean,
template_var = template_var,
BOLD = dat_ctr,
mesh=mymesh, #mesh != NULL => use spatial template ICA model
maxQ=3) #no nuisance ICs
success[ii,2] <- subjIC_stICA_ii$success_flag
nu0_sq_hat[ii,2] <- subjIC_stICA_ii$theta_MLE$nu0_sq
kappa_hat[ii,] <- subjIC_stICA_ii$theta_MLE$kappa
S_stICA[ii,,] <- as.matrix(subjIC_stICA_ii$subjICmean)
S_stICA_var[ii,,] <- as.matrix(subjIC_stICA_ii$subjICvar)
C_stICA1[ii,,] <- cor(subjIC_stICA_ii$A)
C_stICA2[ii,,] <- cor(subjIC_stICA_ii$A_reg)
}
#set.seed(1000)
library(entropy)
x = rnorm(500)
breaks <- seq(-10, 10, 0.1)
hist_x = hist(x, breaks = breaks, plot = FALSE)
entropy(hist_x$counts)
library("plyr")
library("plyr")
library("dplyr")
maxCores()
library(parallel)
maxCores()
detectCores()
help(ldply)
power <- seq(0,t-1)
#set.seed(10000)
t = 500
phi = c(0, 0.1, 0.3, 0.5, 0.7)
simulations = 200
power <- seq(0,t-1)
power
phi1 <- 0.1
phi1^power
cov_mat <- toeplitz(phi1^power)
cov_mat[1:5,1:5]
M = 200
data <- array(NA, dim=c(t,M,length(phi)))
powers <- seq(0,t-1) #powers to raise phi to for covariance matrix
rm(power)
ii=1
phi_ii <- phi[ii]
cov_mat <- toeplitz(phi_ii^powers)
help(mvrnorm)
library(MASS) #mvrnorm
cov_mat <- toeplitz(c(1, 0.5, 0.5^2))
cov_mat
solve(cov_mat)
cov_mat <- toeplitz(c(1, 0.5, 0.5^2, 0.5^3, 0.5^4))
solve(cov_mat)
dat_ii <- mvrnorm(n = M, mu = rep(0, t), Sigma = cov_mat)
dim(cov_mat)
phi_ii <- phi[ii]
cov_mat <- toeplitz(phi_ii^powers)
dat_ii <- mvrnorm(n = M, mu = rep(0, t), Sigma = cov_mat)
dim(dat_ii)
hist_ii <- apply(dat_ii, 2, function(x){
hist_x <- hist(x, breaks=breaks, plot=FALSE)
})
dim(hist_ii)
hist_ii <- apply(dat_ii, 2, function(x){
hist_x <- hist(x, breaks=breaks, plot=FALSE)
return(hist_x$counts)
})
dim(hist_ii)
length(breaks)
entropy(hist_ii[,1])
install.packages()
install.packages('BioCQ')
install.packages('BioQC')
install.packages("BiocManager")
BiocManager::install("BioQC")
help(entropy)
library(BioQC)
help(entropy::entropy)
help(BioQC::entropy)
help(entropy)
BioQC::entropy(vector = hist_ii[,1])
entropy::entropy(hist_ii[,1])
log(sqrt(2*pi*exp()))
log(sqrt(2*pi*exp(1)))
#set.seed(10000)
t = 5000
phi = c(0, 0.1, 0.3, 0.5, 0.7)
M = 200
powers <- seq(0,t-1) #powers to raise phi to for covariance matrix
breaks <- seq(-10, 10, 0.001) #breaks for all the histograms
phi_ii <- phi[ii]
cov_mat <- toeplitz(phi_ii^powers)
dat_ii <- mvrnorm(n = M, mu = rep(0, t), Sigma = cov_mat)
#set.seed(10000)
t = 1000
phi = c(0, 0.1, 0.3, 0.5, 0.7)
dim(dat_ii)
head(dat_ii[,1:5])
head(dat_ii[,495:500])
tail(dat_ii[,495:500])
hist_ii1 <- hist(dat_ii[,1], breaks=breaks, plot=FALSE)
hist_ii1 <- hist_ii1$counts
length(hist_ii1)
entropy::entropy(hist_ii1)
BioQC::entropy(hist_ii1)
t
phi_ii <- phi[ii]
cov_mat <- toeplitz(phi_ii^powers)
system.time(dat_ii_dep <- mvrnorm(n = M, mu = rep(0, t), Sigma = cov_mat))
dim(cov_mat)
powers <- seq(0,t-1) #powers to raise phi to for covariance matrix
cov_mat <- toeplitz(phi_ii^powers)
system.time(dat_ii_dep <- mvrnorm(n = M, mu = rep(0, t), Sigma = cov_mat))
dat_ii_indep <- matrix(rnorm(n = t*M), nrow=t, ncol=M)
hist_ii2 <- hist(dat_ii[,2], breaks=breaks, plot=FALSE)
hist_ii <- cbind(hist_ii1, hist_ii2)
length(hist_ii1)
length(hist_ii2)
dim(dat_ii)
head(breaks)
hist_ii2 <- hist_ii2$counts
hist_ii <- cbind(hist_ii1, hist_ii2)
entropy(hist_ii[,1])
entropy(hist_ii[,2])
help(bioQC)
entropyDiversity(hist_ii)
entropy_sample <- function(x, breaks){
hist_x <- hist(x, breaks=breaks, plot=FALSE)
return(entropy::entropy(hist_x$counts))
}
entropy_dist_indep <- matrix(NA, nrow=M, ncol=length(phi))
entropy_dist_dep <- matrix(NA, nrow=M, ncol=length(phi))
powers <- seq(0,t-1) #powers to raise phi to for covariance matrix
breaks <- seq(-10, 10, 0.001) #breaks for all the histograms
entropy_dist_indep <- matrix(NA, nrow=M, ncol=length(phi))
entropy_dist_dep <- matrix(NA, nrow=M, ncol=length(phi))
for(ii in 1:length(phi)){
phi_ii <- phi[ii]
cov_mat <- toeplitz(phi_ii^powers)
dat_ii_indep <- matrix(rnorm(n = t*M), nrow=t, ncol=M)
dat_ii_dep <- mvrnorm(n = M, mu = rep(0, t), Sigma = cov_mat)
entropy_ii_indep <- apply(dat_ii_indep, 2, entropy_sample)
entropy_ii_dep <- apply(dat_ii_dep, 2, entropy_sample)
entropy_dist_indep[,ii] <- entropy_ii_indep
entropy_dist_dep[,ii] <- entropy_ii_dep
}
breaks <- seq(-10, 10, 0.001) #breaks for all the histograms
powers <- seq(0,t-1) #powers to raise phi to for covariance matrix
breaks <- seq(-10, 10, 0.001) #breaks for all the histograms
entropy_dist_indep <- matrix(NA, nrow=M, ncol=length(phi))
entropy_dist_dep <- matrix(NA, nrow=M, ncol=length(phi))
for(ii in 1:length(phi)){
print(ii)
phi_ii <- phi[ii]
cov_mat <- toeplitz(phi_ii^powers)
dat_ii_indep <- matrix(rnorm(n = t*M), nrow=t, ncol=M)
dat_ii_dep <- mvrnorm(n = M, mu = rep(0, t), Sigma = cov_mat)
entropy_ii_indep <- apply(dat_ii_indep, 2, entropy_sample, breaks=breaks)
entropy_ii_dep <- apply(dat_ii_dep, 2, entropy_sample, breaks=breaks)
entropy_dist_indep[,ii] <- entropy_ii_indep
entropy_dist_dep[,ii] <- entropy_ii_dep
}
length(entropy_ii_dep)
M
dim(dat_ii_dep)
t
library(knitr)
install_github('mandymejia/BayesfMRI')
library(devtools)
install_github('mandymejia/BayesfMRI')
